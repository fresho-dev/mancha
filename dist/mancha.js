(()=>{"use strict";class t{timeouts=new Map;debounce(t,e){return new Promise(((s,r)=>{const i=this.timeouts.get(e);i&&clearTimeout(i),this.timeouts.set(e,setTimeout((()=>{try{s(e()),this.timeouts.delete(e)}catch(t){r(t)}}),t))}))}}function e(t,r,i=!0){if(null==t||function(t){return t instanceof s||t.__is_proxy__}(t))return t;if(i)for(const s in t)t.hasOwnProperty(s)&&"object"==typeof t[s]&&null!=t[s]&&(t[s]=e(t[s],r));return new Proxy(t,{deleteProperty:(t,e)=>e in t&&(delete t[e],r(),!0),set:(t,s,a,n)=>{i&&"object"==typeof a&&(a=e(a,r));const o=Reflect.set(t,s,a,n);return r(),o},get:(t,e,s)=>"__is_proxy__"===e||Reflect.get(t,e,s)})}class s extends t{value=null;listeners=[];constructor(t=null,...e){super(),this.value=this.wrapObjValue(t),e.forEach((t=>this.watch(t)))}static from(t,...e){return t instanceof s?(e.forEach(t.watch),t):new s(t,...e)}wrapObjValue(t){return null===t||"object"!=typeof t?t:e(t,(()=>this.trigger()))}get(){return this.value}async set(t){if(this.value!==t){const e=this.value;this.value=this.wrapObjValue(t),await this.trigger(e)}}watch(t){this.listeners.push(t)}unwatch(t){this.listeners=this.listeners.filter((e=>e!==t))}trigger(t=null){const e=this.listeners.slice();return this.debounce(10,(()=>Promise.all(e.map((e=>e(this.value,t)))).then((()=>{}))))}}class r extends t{store=new Map;debouncedListeners=new Map;lock=Promise.resolve();constructor(t){super();for(const[e,r]of Object.entries(t||{}))this.store.set(e,s.from(this.wrapFnValue(r)))}wrapFnValue(t){return t&&"function"==typeof t?(...e)=>t.call(i(this),...e):t}get $(){return i(this)}entries(){return this.store.entries()}get(t){return this.store.get(t)?.get()}async set(t,e){this.store.has(t)?await this.store.get(t).set(this.wrapFnValue(e)):this.store.set(t,s.from(this.wrapFnValue(e)))}del(t){return this.store.delete(t)}has(t){return this.store.has(t)}async update(t){await Promise.all(Object.entries(t).map((([t,e])=>this.set(t,e))))}watch(t,e){t=Array.isArray(t)?t:[t];const s=()=>e(...t.map((t=>this.store.get(t).get()))),r=()=>this.debounce(10,s);t.forEach((t=>this.store.get(t).watch(r))),this.debouncedListeners.set(e,r)}unwatch(t,e){(t=Array.isArray(t)?t:[t]).forEach((t=>this.store.get(t).unwatch(this.debouncedListeners.get(e)))),this.debouncedListeners.delete(e)}async trigger(t){t=Array.isArray(t)?t:[t],await Promise.all(t.map((t=>this.store.get(t).trigger())))}async trace(t){const e=new Set,s=i(this,((t,s)=>{"get"===t&&e.add(s)}));return[await t.call(s),Array.from(e)]}async computed(t,e){const[s,r]=await this.trace(e);this.watch(r,(async()=>this.set(t,await e.call(i(this))))),this.set(t,s)}}function i(t,e=(()=>{})){const s=Array.from(t.entries()).map((([t])=>t)),r=Object.fromEntries(s.map((t=>[t,void 0])));return new Proxy(Object.assign({},t,r),{get:(s,r,i)=>"string"==typeof r&&t.has(r)?(e("get",r),t.get(r)):"get"===r?s=>(e("get",s),t.get(s)):Reflect.get(t,r,i),set:(s,r,i,a)=>("string"!=typeof r||r in t?Reflect.set(t,r,i,a):(e("set",r,i),t.set(r,i)),!0)})}class a{iterable;constructor(t){this.iterable=t}filter(t){return new a(a.filterGenerator(t,this.iterable))}map(t){return new a(a.mapGenerator(t,this.iterable))}array(){return Array.from(this.iterable)}*generator(){for(const t of this.iterable)yield t}static*filterGenerator(t,e){for(const s of e)t(s)&&(yield s)}static*mapGenerator(t,e){for(const s of e)yield t(s)}static equals(t,e){const s=t[Symbol.iterator](),r=e[Symbol.iterator]();let i=s.next(),a=r.next();for(;!i.done&&!a.done;){if(i.value!==a.value)return!1;i=s.next(),a=r.next()}return i.done===a.done}}const n=new Set([":bind",":bind-events",":data",":for",":show","@watch","$html"]),o={$text:"$text-content"};var c;function*l(t,e=new Set){const s=new Set,r=Array.from(t.childNodes).filter((t=>!e.has(t)));for(yield t;r.length;){const t=r.pop();s.has(t)||(s.add(t),yield t),t.childNodes&&Array.from(t.childNodes).filter((t=>!e.has(t))).forEach((t=>r.push(t)))}}function h(t){return t.includes("/")?t.split("/").slice(0,-1).join("/"):""}function u(t){return!(t.includes("://")||t.startsWith("/")||t.startsWith("#")||t.startsWith("data:"))}!function(t){t.resolveIncludes=async function(t,e){const s=t;if("include"!==s.tagName?.toLocaleLowerCase())return;this.log("<include> tag found in:\n",t),this.log("<include> params:",e);const r=s.getAttribute?.("src");if(!r)throw new Error(`"src" attribute missing from ${t}.`);const i=e=>{t.replaceWith(...Array.from(e.childNodes))},a={...e,root:!1,maxdepth:e?.maxdepth-1};if(0===a.maxdepth)throw new Error("Maximum recursion depth reached.");if(r.includes("://")||r.startsWith("//"))this.log("Including remote file from absolute path:",r),await this.preprocessRemote(r,a).then(i);else if(e?.dirpath?.includes("://")||e?.dirpath?.startsWith("//")){const t=e.dirpath&&"."!==e.dirpath?`${e.dirpath}/${r}`:r;this.log("Including remote file from relative path:",t),await this.preprocessRemote(t,a).then(i)}else if("/"===r.charAt(0))this.log("Including local file from absolute path:",r),await this.preprocessLocal(r,a).then(i);else{const t=e?.dirpath&&"."!==e?.dirpath?`${e?.dirpath}/${r}`:r;this.log("Including local file from relative path:",t),await this.preprocessLocal(t,a).then(i)}},t.rebaseRelativePaths=async function(t,e){const s=t,r=s.tagName?.toLowerCase();if(!e?.dirpath)return;const i=t.getAttribute?.("src"),a=t.getAttribute?.("href"),n=t.getAttribute?.("data"),o=i||a||n;o&&(o&&u(o)&&this.log("Rebasing relative path as:",e.dirpath,"/",o),"img"===r&&i&&u(i)?s.src=`${e.dirpath}/${i}`:"a"===r&&a&&u(a)||"link"===r&&a&&u(a)?s.href=`${e.dirpath}/${a}`:"script"===r&&i&&u(i)||"source"===r&&i&&u(i)||"audio"===r&&i&&u(i)||"video"===r&&i&&u(i)||"track"===r&&i&&u(i)||"iframe"===r&&i&&u(i)?s.src=`${e.dirpath}/${i}`:"object"===r&&n&&u(n)?s.data=`${e.dirpath}/${n}`:"input"===r&&i&&u(i)?s.src=`${e.dirpath}/${i}`:("area"===r&&a&&u(a)||"base"===r&&a&&u(a))&&(s.href=`${e.dirpath}/${a}`))},t.resolveTextNodeExpressions=async function(t,e){if(3!==t.nodeType)return;const s=t.nodeValue||"";this.log("Processing node content value:\n",s);const r=new RegExp(/{{ ([^}]+) }}/gm),i=Array.from(s.matchAll(r)).map((t=>t[1])),a=async()=>{let e=s;for(const s of i){const[r]=await this.eval(s,{$elem:t});e=e.replace(`{{ ${s} }}`,String(r))}t.nodeValue=e};await Promise.all(i.map((e=>this.watchExpr(e,{$elem:t},a))))},t.resolveDataAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,r=s.getAttribute?.(":data");if(r){this.log(":data attribute found in:\n",t),s.removeAttribute(":data");const[e]=await this.eval(r,{$elem:t});await this.update(e)}},t.resolveWatchAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,r=s.getAttribute?.("@watch");r&&(this.log("@watch attribute found in:\n",t),s.removeAttribute("@watch"),await this.watchExpr(r,{$elem:t},(()=>{})))},t.resolveHtmlAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,r=s.getAttribute?.("$html");if(r){this.log("$html attribute found in:\n",t),s.removeAttribute("$html");const i=this.clone();await this.watchExpr(r,{$elem:t},(async t=>{const r=await i.preprocessString(t,e);await i.renderNode(r,e),s.replaceChildren(r)}))}},t.resolvePropAttributes=async function(t,e){if(this._skipNodes.has(t))return;const s=t;for(const e of Array.from(s.attributes||[]))if(e.name.startsWith("$")&&!n.has(e.name)){this.log(e.name,"attribute found in:\n",t),s.removeAttribute(e.name);const r=(o[e.name]||e.name).slice(1).replace(/-./g,(t=>t[1].toUpperCase()));await this.watchExpr(e.value,{$elem:t},(e=>t[r]=e))}},t.resolveAttrAttributes=async function(t,e){if(this._skipNodes.has(t))return;const s=t;for(const e of Array.from(s.attributes||[]))if(e.name.startsWith(":")&&!n.has(e.name)){this.log(e.name,"attribute found in:\n",t),s.removeAttribute(e.name);const r=(o[e.name]||e.name).slice(1);await this.watchExpr(e.value,{$elem:t},(t=>s.setAttribute(r,t)))}},t.resolveEventAttributes=async function(t,e){if(this._skipNodes.has(t))return;const s=t;for(const e of Array.from(s.attributes||[]))e.name.startsWith("@")&&!n.has(e.name)&&(this.log(e.name,"attribute found in:\n",t),s.removeAttribute(e.name),t.addEventListener?.(e.name.substring(1),(s=>{this.eval(e.value,{$elem:t,$event:s})})))},t.resolveForAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,r=s.getAttribute?.(":for")?.trim();if(r){this.log(":for attribute found in:\n",t),s.removeAttribute(":for");for(const e of l(t,this._skipNodes))this._skipNodes.add(e);const i=t.parentNode,a=t.ownerDocument.createElement("template");i.insertBefore(a,t),a.append(t),this.log(":for template:\n",a);const n=r.split(" in ",2);if(2!==n.length)throw new Error(`Invalid :for format: \`${r}\`. Expected "{key} in {expression}".`);const o=[],[c,h]=n;await this.watchExpr(h,{$elem:t},(s=>(this.log(":for list items:",s),this.lock=this.lock.then((()=>new Promise((async r=>{if(o.splice(0,o.length).forEach((t=>{i.removeChild(t),this._skipNodes.delete(t)})),!Array.isArray(s))return console.error(`Expression did not yield a list: \`${h}\` => \`${s}\``),r();for(const r of s.slice(0).reverse()){const s=this.clone();await s.set(c,r);const n=t.cloneNode(!0);i.insertBefore(n,a.nextSibling),o.push(n),this._skipNodes.add(n),await s.mount(n,e),this.log("Rendered list child:\n",n,n.outerHTML)}r()})))),this.lock)))}},t.resolveBindAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,r=s.getAttribute?.(":bind");if(r){this.log(":bind attribute found in:\n",t);const e=["change","input"],i=s.getAttribute?.(":bind-events")?.split(",")||e;s.removeAttribute(":bind"),s.removeAttribute(":bind-events");const a="checkbox"===s.getAttribute("type")?"checked":"value",n=`$elem.${a} = ${r}`;await this.watchExpr(n,{$elem:t},(t=>s[a]=t));const o=`${r} = $elem.${a}`;for(const e of i)t.addEventListener(e,(()=>this.eval(o,{$elem:t})))}},t.resolveShowAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,r=s.getAttribute?.(":show");if(r){this.log(":show attribute found in:\n",t),s.removeAttribute(":show");const e="none"===s.style.display?"":s.style.display;await this.watchExpr(r,{$elem:t},(t=>{s.style.display=t?e:"none"}))}}}(c||(c={}));class d extends r{debugging=!1;dirpath="";evalkeys=["$elem","$event"];expressionCache=new Map;evalCallbacks=new Map;_skipNodes=new Set;debug(t){return this.debugging=t,this}async fetchRemote(t,e){return fetch(t,{cache:e?.cache??"default"}).then((t=>t.text()))}async fetchLocal(t,e){return this.fetchRemote(t,e)}async preprocessString(t,e){this.log("Preprocessing string content with params:\n",e);const s=this.parseHTML(t,e);return await this.preprocessNode(s,e),s}async preprocessLocal(t,e){const s=await this.fetchLocal(t,e);return this.preprocessString(s,{...e,dirpath:h(t),root:e?.root??!t.endsWith(".tpl.html")})}async preprocessRemote(t,e){const s=e?.cache||"default",r=await fetch(t,{cache:s}).then((t=>t.text()));return this.preprocessString(r,{...e,dirpath:h(t),root:e?.root??!t.endsWith(".tpl.html")})}clone(){return new this.constructor(Object.fromEntries(this.store.entries())).debug(this.debugging)}log(...t){this.debugging&&console.debug(...t)}cachedExpressionFunction(t){return this.expressionCache.has(t)||this.expressionCache.set(t,function(t,e=[]){return new Function(...e,`with (this) { return (async () => (${t}))(); }`)}(t,this.evalkeys)),this.expressionCache.get(t)}async eval(t,e={}){const s=this.cachedExpressionFunction(t),r=this.evalkeys.map((t=>e[t]));if(Object.keys(e).some((t=>!this.evalkeys.includes(t))))throw new Error(`Invalid argument key, must be one of: ${this.evalkeys.join(", ")}`);const[i,a]=await this.trace((async function(){return s.call(this,...r)}));return this.log(`eval \`${t}\` => `,i,`[ ${a.join(", ")} ]`),[i,a]}watchExpr(t,e,s){if(this.evalCallbacks.has(t))return this.evalCallbacks.get(t)?.push(s),this.eval(t,e).then((([t,e])=>s(t,e)));this.evalCallbacks.set(t,[s]);const r=[],i=async()=>{const[s,a]=await this.eval(t,e),n=this.evalCallbacks.get(t)||[];await Promise.all(n.map((t=>t(s,a)))),r.length>0&&this.unwatch(r,i),r.splice(0,r.length,...a),this.watch(a,i)};return i()}async preprocessNode(t,e){e=Object.assign({dirpath:this.dirpath,maxdepth:10},e);const s=new a(l(t,this._skipNodes)).map((async t=>{this.log("Preprocessing node:\n",t),await c.resolveIncludes.call(this,t,e),await c.rebaseRelativePaths.call(this,t,e)}));await Promise.all(s.generator())}async renderNode(t,e){for(const s of l(t,this._skipNodes))this.log("Rendering node:\n",s),await c.resolveDataAttribute.call(this,s,e),await c.resolveForAttribute.call(this,s,e),await c.resolveHtmlAttribute.call(this,s,e),await c.resolveShowAttribute.call(this,s,e),await c.resolveWatchAttribute.call(this,s,e),await c.resolveBindAttribute.call(this,s,e),await c.resolvePropAttributes.call(this,s,e),await c.resolveAttrAttributes.call(this,s,e),await c.resolveEventAttributes.call(this,s,e),await c.resolveTextNodeExpressions.call(this,s,e);return t}async mount(t,e){await this.preprocessNode(t,e),await this.renderNode(t,e)}}const p=new class extends d{dirpath=h(self.location.href);parseHTML(t,e={root:!1}){if(e.root)return(new DOMParser).parseFromString(t,"text/html");{const e=document.createRange();return e.selectNodeContents(document.body),e.createContextualFragment(t)}}serializeHTML(t){return(new XMLSerializer).serializeToString(t).replace(/\s?xmlns="[^"]+"/gm,"")}preprocessLocal(t,e){return this.preprocessRemote(t,e)}};self.Mancha=p;const f=self.document?.currentScript;if(self.document?.currentScript?.hasAttribute("init")){const t=f?.hasAttribute("debug"),e=f?.getAttribute("cache"),s=f?.getAttribute("target")?.split(",")||["body"];window.addEventListener("load",(()=>{s.map((async s=>{const r=self.document.querySelector(s);await p.debug(t).mount(r,{cache:e})}))}))}})();