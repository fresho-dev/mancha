(()=>{"use strict";class t{timeouts=new Map;debounce(t,e){return new Promise(((s,n)=>{const r=this.timeouts.get(e);r&&clearTimeout(r),this.timeouts.set(e,setTimeout((()=>{try{s(e()),this.timeouts.delete(e)}catch(t){n(t)}}),t))}))}}function e(t,n,r=!0){if(null==t||function(t){return t instanceof s||t.__is_proxy__}(t)||t instanceof Promise)return t;if(r)for(const s in t)t.hasOwnProperty(s)&&"object"==typeof t[s]&&null!=t[s]&&(t[s]=e(t[s],n));return new Proxy(t,{deleteProperty:(t,e)=>e in t&&(delete t[e],n(),!0),set:(t,s,i,a)=>{r&&"object"==typeof i&&(i=e(i,n));const o=Reflect.set(t,s,i,a);return n(),o},get:(t,e,s)=>"__is_proxy__"===e||Reflect.get(t,e,s)})}class s extends t{value=null;listeners=[];constructor(t=null,...e){super(),this.value=this.wrapObjValue(t),e.forEach((t=>this.watch(t)))}static from(t,...e){return t instanceof s?(e.forEach(t.watch),t):new s(t,...e)}wrapObjValue(t){return null===t||"object"!=typeof t?t:e(t,(()=>this.trigger()))}get(){return this.value}async set(t){if(this.value!==t){const e=this.value;this.value=this.wrapObjValue(t),await this.trigger(e)}}watch(t){this.listeners.push(t)}unwatch(t){this.listeners=this.listeners.filter((e=>e!==t))}trigger(t=null){const e=this.listeners.slice();return this.debounce(10,(()=>Promise.all(e.map((e=>e(this.value,t)))).then((()=>{}))))}}class n extends t{store=new Map;debouncedListeners=new Map;lock=Promise.resolve();constructor(t){super();for(const[e,n]of Object.entries(t||{}))this.store.set(e,s.from(this.wrapFnValue(n)))}wrapFnValue(t){return t&&"function"==typeof t?(...e)=>t.call(r(this),...e):t}get $(){return r(this)}entries(){return this.store.entries()}get(t){return this.store.get(t)?.get()}async set(t,e){this.store.has(t)?await this.store.get(t).set(this.wrapFnValue(e)):this.store.set(t,s.from(this.wrapFnValue(e)))}del(t){return this.store.delete(t)}has(t){return this.store.has(t)}async update(t){await Promise.all(Object.entries(t).map((([t,e])=>this.set(t,e))))}watch(t,e){t=Array.isArray(t)?t:[t];const s=()=>e(...t.map((t=>this.store.get(t).get()))),n=()=>this.debounce(10,s);t.forEach((t=>this.store.get(t).watch(n))),this.debouncedListeners.set(e,n)}unwatch(t,e){(t=Array.isArray(t)?t:[t]).forEach((t=>this.store.get(t).unwatch(this.debouncedListeners.get(e)))),this.debouncedListeners.delete(e)}async trigger(t){t=Array.isArray(t)?t:[t],await Promise.all(t.map((t=>this.store.get(t).trigger())))}async trace(t){const e=new Set,s=r(this,((t,s)=>{"get"===t&&e.add(s)}));return[await t.call(s),Array.from(e)]}async computed(t,e){const[s,n]=await this.trace(e);this.watch(n,(async()=>this.set(t,await e.call(r(this))))),this.set(t,s)}}function r(t,e=(()=>{})){const s=Array.from(t.entries()).map((([t])=>t)),n=Object.fromEntries(s.map((t=>[t,void 0])));return new Proxy(Object.assign({},t,n),{get:(s,n,r)=>"string"==typeof n&&t.has(n)?(e("get",n),t.get(n)):"get"===n?s=>(e("get",s),t.get(s)):Reflect.get(t,n,r),set:(s,n,r,i)=>("string"!=typeof n||n in t?Reflect.set(t,n,r,i):(e("set",n,r),t.set(n,r)),!0)})}class i{iterable;constructor(t){this.iterable=t}filter(t){return new i(i.filterGenerator(t,this.iterable))}map(t){return new i(i.mapGenerator(t,this.iterable))}find(t){for(const e of this.iterable)if(t(e))return e}array(){return Array.from(this.iterable)}*generator(){for(const t of this.iterable)yield t}static*filterGenerator(t,e){for(const s of e)t(s)&&(yield s)}static*mapGenerator(t,e){for(const s of e)yield t(s)}static equals(t,e){const s=t[Symbol.iterator](),n=e[Symbol.iterator]();let r=s.next(),i=n.next();for(;!r.done&&!i.done;){if(r.value!==i.value)return!1;r=s.next(),i=n.next()}return r.done===i.done}}var a,o;(o=a||(a={})).Root="root",o.Text="text",o.Directive="directive",o.Comment="comment",o.Script="script",o.Style="style",o.Tag="tag",o.CDATA="cdata",o.Doctype="doctype",a.Root,a.Text,a.Directive,a.Comment,a.Script,a.Style,a.Tag,a.CDATA,a.Doctype;class c{constructor(){this.parent=null,this.prev=null,this.next=null,this.startIndex=null,this.endIndex=null}get parentNode(){return this.parent}set parentNode(t){this.parent=t}get previousSibling(){return this.prev}set previousSibling(t){this.prev=t}get nextSibling(){return this.next}set nextSibling(t){this.next=t}cloneNode(t=!1){return w(this,t)}}class l extends c{constructor(t){super(),this.data=t}get nodeValue(){return this.data}set nodeValue(t){this.data=t}}class h extends l{constructor(){super(...arguments),this.type=a.Text}get nodeType(){return 3}}class u extends l{constructor(){super(...arguments),this.type=a.Comment}get nodeType(){return 8}}class d extends l{constructor(t,e){super(e),this.name=t,this.type=a.Directive}get nodeType(){return 1}}class p extends c{constructor(t){super(),this.children=t}get firstChild(){var t;return null!==(t=this.children[0])&&void 0!==t?t:null}get lastChild(){return this.children.length>0?this.children[this.children.length-1]:null}get childNodes(){return this.children}set childNodes(t){this.children=t}}class f extends p{constructor(){super(...arguments),this.type=a.CDATA}get nodeType(){return 4}}class m extends p{constructor(){super(...arguments),this.type=a.Root}get nodeType(){return 9}}class g extends p{constructor(t,e,s=[],n=("script"===t?a.Script:"style"===t?a.Style:a.Tag)){super(s),this.name=t,this.attribs=e,this.type=n}get nodeType(){return 1}get tagName(){return this.name}set tagName(t){this.name=t}get attributes(){return Object.keys(this.attribs).map((t=>{var e,s;return{name:t,value:this.attribs[t],namespace:null===(e=this["x-attribsNamespace"])||void 0===e?void 0:e[t],prefix:null===(s=this["x-attribsPrefix"])||void 0===s?void 0:s[t]}}))}}function w(t,e=!1){let s;if(function(t){return t.type===a.Text}(t))s=new h(t.data);else if(function(t){return t.type===a.Comment}(t))s=new u(t.data);else if(function(t){return(e=t).type===a.Tag||e.type===a.Script||e.type===a.Style;var e}(t)){const n=e?y(t.children):[],r=new g(t.name,{...t.attribs},n);n.forEach((t=>t.parent=r)),null!=t.namespace&&(r.namespace=t.namespace),t["x-attribsNamespace"]&&(r["x-attribsNamespace"]={...t["x-attribsNamespace"]}),t["x-attribsPrefix"]&&(r["x-attribsPrefix"]={...t["x-attribsPrefix"]}),s=r}else if(function(t){return t.type===a.CDATA}(t)){const n=e?y(t.children):[],r=new f(n);n.forEach((t=>t.parent=r)),s=r}else if(function(t){return t.type===a.Root}(t)){const n=e?y(t.children):[],r=new m(n);n.forEach((t=>t.parent=r)),t["x-mode"]&&(r["x-mode"]=t["x-mode"]),s=r}else{if(!function(t){return t.type===a.Directive}(t))throw new Error(`Not implemented yet: ${t.type}`);{const e=new d(t.name,t.data);null!=t["x-name"]&&(e["x-name"]=t["x-name"],e["x-publicId"]=t["x-publicId"],e["x-systemId"]=t["x-systemId"]),s=e}}return s.startIndex=t.startIndex,s.endIndex=t.endIndex,null!=t.sourceCodeLocation&&(s.sourceCodeLocation=t.sourceCodeLocation),s}function y(t){const e=t.map((t=>w(t,!0)));for(let t=1;t<e.length;t++)e[t].prev=e[t-1],e[t-1].next=e[t];return e}function*b(t,e=new Set){const s=new Set,n=Array.from(t.childNodes).filter((t=>!e.has(t)));for(yield t;n.length;){const t=n.shift();s.has(t)||(s.add(t),yield t),t.childNodes&&Array.from(t.childNodes).filter((t=>!e.has(t))).forEach((t=>n.push(t)))}}function v(t,e){return"function"==typeof t?.[e]}function x(t,e){return t instanceof g?t.attribs?.[e]:t.getAttribute?.(e)}function N(t,e,s){t instanceof g?t.attribs[e]=s:t.setAttribute?.(e,s)}function A(t,e){t instanceof g?delete t.attribs[e]:t.removeAttribute?.(e)}function $(t,e,s){if(t instanceof g&&e instanceof g)e.attribs[s]=t.attribs[s];else{const n=t?.getAttributeNode?.(s);e?.setAttributeNode?.(n?.cloneNode(!0))}}function E(t,...e){if(v(t,"replaceWith"))return t.replaceWith(...e);{const s=t,n=s.parentNode,r=Array.from(n.childNodes).indexOf(s);e.forEach((t=>t.parentNode=n)),n.childNodes=[].concat(Array.from(n.childNodes).slice(0,r)).concat(e).concat(Array.from(n.childNodes).slice(r+1))}}function C(t,e){return v(e,"appendChild")?t.appendChild(e):(t.childNodes.push(e),e.parentNode=t,e)}function k(t,e){if(v(e,"removeChild"))return t.removeChild(e);{const s=e;return t.childNodes=t.children.filter((t=>t!==s)),s}}function _(t,e,s){return s?v(t,"insertBefore")?t.insertBefore(e,s):(E(s,e,s),e):C(t,e)}window.htmlparser2;const S=new Set([":bind",":bind-events",":data",":for",":show","@watch","$html"]);var T;function L(t){return t.includes("/")?t.split("/").slice(0,-1).join("/"):""}function P(t){return!(t.includes("://")||t.startsWith("/")||t.startsWith("#")||t.startsWith("data:"))}!function(t){t.resolveIncludes=async function(t,e){const s=t;if("include"!==s.tagName?.toLocaleLowerCase())return;this.log("<include> tag found in:\n",t),this.log("<include> params:",e);const n=x(s,"src");if(!n)throw new Error(`"src" attribute missing from ${t}.`);const r=e=>{const n=e.firstChild;for(const t of Array.from(s.attributes))n&&"src"!==t.name&&$(s,n,t.name);E(t,...e.childNodes)},i={...e,rootDocument:!1,maxdepth:e?.maxdepth-1};if(0===i.maxdepth)throw new Error("Maximum recursion depth reached.");if(n.includes("://")||n.startsWith("//"))this.log("Including remote file from absolute path:",n),await this.preprocessRemote(n,i).then(r);else if(e?.dirpath?.includes("://")||e?.dirpath?.startsWith("//")){const t=n.startsWith("/")?n:`${e.dirpath}/${n}`;this.log("Including remote file from relative path:",t),await this.preprocessRemote(t,i).then(r)}else if("/"===n.charAt(0))this.log("Including local file from absolute path:",n),await this.preprocessLocal(n,i).then(r);else{const t=e?.dirpath&&"."!==e?.dirpath?`${e?.dirpath}/${n}`:n;this.log("Including local file from relative path:",t),await this.preprocessLocal(t,i).then(r)}},t.rebaseRelativePaths=async function(t,e){const s=t,n=s.tagName?.toLowerCase();if(!e?.dirpath)return;const r=x(s,"src"),i=x(s,"href"),a=x(s,"data"),o=r||i||a;o&&(o&&P(o)&&this.log("Rebasing relative path as:",e.dirpath,"/",o),"img"===n&&r&&P(r)?N(s,"src",`${e.dirpath}/${r}`):"a"===n&&i&&P(i)||"link"===n&&i&&P(i)?N(s,"href",`${e.dirpath}/${i}`):"script"===n&&r&&P(r)||"source"===n&&r&&P(r)||"audio"===n&&r&&P(r)||"video"===n&&r&&P(r)||"track"===n&&r&&P(r)||"iframe"===n&&r&&P(r)?N(s,"src",`${e.dirpath}/${r}`):"object"===n&&a&&P(a)?N(s,"data",`${e.dirpath}/${a}`):"input"===n&&r&&P(r)?N(s,"src",`${e.dirpath}/${r}`):("area"===n&&i&&P(i)||"base"===n&&i&&P(i))&&N(s,"href",`${e.dirpath}/${i}`))},t.registerCustomElements=async function(t,e){const s=t;if("template"===s.tagName?.toLowerCase()&&x(s,"is")){const t=x(s,"is")?.toLowerCase();this._customElements.has(t)||(this.log(`Registering custom element: ${t}\n`,s),this._customElements.set(t,s.cloneNode(!0)),k(s.parentNode,s))}},t.resolveCustomElements=async function(t,e){const s=t,n=s.tagName?.toLowerCase();if(this._customElements.has(n)){this.log(`Processing custom element: ${n}\n`,s);const e=this._customElements.get(n),r=(e.content||e).cloneNode(!0),a=function(t){return t instanceof g?t.children.find((t=>t instanceof g)):t.firstElementChild}(r);for(const t of Array.from(s.attributes))a&&$(s,a,t.name);const o=new i(b(r)).find((t=>"slot"===t.tagName?.toLowerCase()));o&&E(o,...s.childNodes),E(t,...r.childNodes)}},t.resolveTextNodeExpressions=async function(t,e){if(3!==t.nodeType)return;const s=function(t){return t instanceof c?t.data:t.nodeValue}(t)||"";this.log("Processing node content value:\n",s);const n=new RegExp(/{{ ([^}]+) }}/gm),r=Array.from(s.matchAll(n)).map((t=>t[1])),i=async()=>{let e=s;for(const s of r){const[n]=await this.eval(s,{$elem:t});e=e.replace(`{{ ${s} }}`,String(n))}!function(t,e){t instanceof c?t.data=e:t.nodeValue=e}(t,e)};await Promise.all(r.map((e=>this.watchExpr(e,{$elem:t},i))))},t.resolveDataAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,n=x(s,":data");if(n)if(this.log(":data attribute found in:\n",t),A(s,":data"),e?.rootNode===t){const[e]=await this.eval(n,{$elem:t});await this.update(e)}else{const s=this.clone();t.renderer=s;const[r]=await s.eval(n,{$elem:t});await s.update(r);for(const e of b(t,this._skipNodes))this._skipNodes.add(e);await s.mount(t,e)}},t.resolveWatchAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,n=x(s,"@watch");n&&(this.log("@watch attribute found in:\n",t),A(s,"@watch"),await this.watchExpr(n,{$elem:t},(()=>{})))},t.resolveTextAttributes=async function(t,e){if(this._skipNodes.has(t))return;const s=t,n=x(s,"$text");n&&(this.log("$text attribute found in:\n",t),A(s,"$text"),await this.watchExpr(n,{$elem:t},(e=>function(t,e){t instanceof g?t.children=[new h(e)]:t.textContent=e}(t,e))))},t.resolveHtmlAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,n=x(s,"$html");if(n){this.log("$html attribute found in:\n",t),A(s,"$html");const r=this.clone();await this.watchExpr(n,{$elem:t},(async t=>{const n=await r.preprocessString(t,e);await r.renderNode(n,e),function(t,...e){v(t,"replaceChildren")?t.replaceChildren(...e):(t.childNodes=e,e.forEach((e=>e.parentNode=t)))}(s,n)}))}},t.resolvePropAttributes=async function(t,e){if(this._skipNodes.has(t))return;const s=t;for(const e of Array.from(s.attributes||[]))if(e.name.startsWith("$")&&!S.has(e.name)){this.log(e.name,"attribute found in:\n",t),A(s,e.name);const n=e.name.slice(1).replace(/-./g,(t=>t[1].toUpperCase()));await this.watchExpr(e.value,{$elem:t},(e=>t[n]=e))}},t.resolveAttrAttributes=async function(t,e){if(this._skipNodes.has(t))return;const s=t;for(const e of Array.from(s.attributes||[]))if(e.name.startsWith(":")&&!S.has(e.name)){this.log(e.name,"attribute found in:\n",t),A(s,e.name);const n=e.name.slice(1);await this.watchExpr(e.value,{$elem:t},(t=>N(s,n,t)))}},t.resolveEventAttributes=async function(t,e){if(this._skipNodes.has(t))return;const s=t;for(const e of Array.from(s.attributes||[]))e.name.startsWith("@")&&!S.has(e.name)&&(this.log(e.name,"attribute found in:\n",t),A(s,e.name),t.addEventListener?.(e.name.substring(1),(s=>{this.eval(e.value,{$elem:t,$event:s})})))},t.resolveForAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,n=x(s,":for")?.trim();if(n){this.log(":for attribute found in:\n",t),A(s,":for");for(const e of b(t,this._skipNodes))this._skipNodes.add(e);const r=t.parentNode,i=function(t,e){return e?e.createElement(t):new g(t,{})}("template",t.ownerDocument);_(r,i,t),k(r,t),C(i,t),this.log(":for template:\n",i);const a=n.split(" in ",2);if(2!==a.length)throw new Error(`Invalid :for format: \`${n}\`. Expected "{key} in {expression}".`);const o=[],[c,l]=a;await this.watchExpr(l,{$elem:t},(s=>(this.log(":for list items:",s),this.lock=this.lock.then((()=>new Promise((async n=>{if(o.splice(0,o.length).forEach((t=>{k(r,t),this._skipNodes.delete(t)})),!Array.isArray(s))return console.error(`Expression did not yield a list: \`${l}\` => \`${s}\``),n();for(const n of s){const s=this.clone();await s.set(c,n);const r=t.cloneNode(!0);o.push(r),this._skipNodes.add(r),await s.mount(r,e),this.log("Rendered list child:\n",r,r.outerHTML)}const a=i.nextSibling;for(const t of o)_(r,t,a);n()})))).catch((t=>{throw console.error(t),new Error(t)})).then(),this.lock)))}},t.resolveBindAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,n=x(s,":bind");if(n){this.log(":bind attribute found in:\n",t);const e=["change","input"],r=x(s,":bind-events")?.split(",")||e;A(s,":bind"),A(s,":bind-events");const i="checkbox"===x(s,"type")?"checked":"value",a=`$elem.${i} = ${n}`;await this.watchExpr(a,{$elem:t},(t=>s[i]=t));const o=`${n} = $elem.${i}`;for(const e of r)t.addEventListener(e,(()=>this.eval(o,{$elem:t})))}},t.resolveShowAttribute=async function(t,e){if(this._skipNodes.has(t))return;const s=t,n=x(s,":show");if(n){this.log(":show attribute found in:\n",t),A(s,":show");const e="none"===s.style?.display?"":s.style?.display??x(s,"style")?.split(";")?.find((t=>"display"===t.split(":")[0]))?.split(":")?.at(1)?.trim();await this.watchExpr(n,{$elem:t},(t=>{s.style?s.style.display=t?e:"none":N(s,"style",`display: ${t?e:"none"};`)}))}}}(T||(T={}));class R extends n{debugging=!1;dirpath="";evalkeys=["$elem","$event"];expressionCache=new Map;evalCallbacks=new Map;_skipNodes=new Set;_customElements=new Map;debug(t){return this.debugging=t,this}async fetchRemote(t,e){return fetch(t,{cache:e?.cache??"default"}).then((t=>t.text()))}async fetchLocal(t,e){return this.fetchRemote(t,e)}async preprocessString(t,e){this.log("Preprocessing string content with params:\n",e);const s=this.parseHTML(t,e);return await this.preprocessNode(s,e),s}async preprocessRemote(t,e){const s={};e?.cache&&(s.cache=e.cache);const n=await fetch(t,s).then((t=>t.text()));return this.preprocessString(n,{...e,dirpath:L(t),rootDocument:e?.rootDocument??!t.endsWith(".tpl.html")})}async preprocessLocal(t,e){const s=await this.fetchLocal(t,e);return this.preprocessString(s,{...e,dirpath:L(t),rootDocument:e?.rootDocument??!t.endsWith(".tpl.html")})}clone(){const t=new this.constructor(Object.fromEntries(this.store.entries()));return t._customElements=this._customElements,t.debug(this.debugging)}log(...t){this.debugging&&console.debug(...t)}cachedExpressionFunction(t){return this.expressionCache.has(t)||this.expressionCache.set(t,function(t,e=[]){return new Function(...e,`with (this) { return (async () => (${t}))(); }`)}(t,this.evalkeys)),this.expressionCache.get(t)}async eval(t,e={}){if(this.store.has(t))return[this.get(t),[t]];{const s=this.cachedExpressionFunction(t),n=this.evalkeys.map((t=>e[t]));if(Object.keys(e).some((t=>!this.evalkeys.includes(t))))throw new Error(`Invalid argument key, must be one of: ${this.evalkeys.join(", ")}`);const[r,i]=await this.trace((async function(){return s.call(this,...n)}));return this.log(`eval \`${t}\` => `,r,`[ ${i.join(", ")} ]`),[r,i]}}watchExpr(t,e,s){if(this.evalCallbacks.has(t))return this.evalCallbacks.get(t)?.push(s),this.eval(t,e).then((([t,e])=>s(t,e)));this.evalCallbacks.set(t,[s]);const n=[],r=async()=>{const[s,i]=await this.eval(t,e),a=this.evalCallbacks.get(t)||[];await Promise.all(a.map((t=>t(s,i)))),n.length>0&&this.unwatch(n,r),n.splice(0,n.length,...i),this.watch(i,r)};return r()}async preprocessNode(t,e){e={dirpath:this.dirpath,maxdepth:10,...e};const s=new i(b(t,this._skipNodes)).map((async t=>{this.log("Preprocessing node:\n",t),await T.resolveIncludes.call(this,t,e),await T.rebaseRelativePaths.call(this,t,e),await T.registerCustomElements.call(this,t,e),await T.resolveCustomElements.call(this,t,e)}));return await Promise.all(s.generator()),t}async renderNode(t,e){for(const s of b(t,this._skipNodes))this.log("Rendering node:\n",s),await T.resolveDataAttribute.call(this,s,e),await T.resolveForAttribute.call(this,s,e),await T.resolveTextAttributes.call(this,s,e),await T.resolveHtmlAttribute.call(this,s,e),await T.resolveShowAttribute.call(this,s,e),await T.resolveWatchAttribute.call(this,s,e),await T.resolveBindAttribute.call(this,s,e),await T.resolvePropAttributes.call(this,s,e),await T.resolveAttrAttributes.call(this,s,e),await T.resolveEventAttributes.call(this,s,e),await T.resolveTextNodeExpressions.call(this,s,e);return t}async mount(t,e){e={...e,rootNode:t},await this.preprocessNode(t,e),await this.renderNode(t,e),t.renderer=this}}const D=new class extends R{dirpath=L(self.location.href);parseHTML(t,e={rootDocument:!1}){if(e.rootDocument)return(new DOMParser).parseFromString(t,"text/html");{const e=document.createRange();return e.selectNodeContents(document.body),e.createContextualFragment(t)}}serializeHTML(t){return(new XMLSerializer).serializeToString(t).replace(/\s?xmlns="[^"]+"/gm,"")}preprocessLocal(t,e){return this.preprocessRemote(t,e)}};self.Mancha=D;const I=self.document?.currentScript;if(self.document?.currentScript?.hasAttribute("init")){const t=I?.hasAttribute("debug"),e=I?.getAttribute("cache"),s=I?.getAttribute("target")?.split(",")||["body"];window.addEventListener("load",(()=>{s.map((async s=>{const n=self.document.querySelector(s);await D.debug(t).mount(n,{cache:e})}))}))}})();